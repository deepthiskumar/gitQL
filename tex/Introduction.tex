%Introduction

%GQL is language to query the history of git repositories. Before going to the GQL, let us first see the need to query the history and how it is done till now is.

%\textbf{Why querying history is important}

One of the advantages of using version control systems (VCS) is that the users of a software repository can look at the evolution of the software. Users can see the changes that led to newer versions. These changes help users or programmers understand the workings of the current version because they can see what changed from the previous version. In the case of software bugs, users can quickly narrow down the part of code that caused it by identifying what changed between the version that worked correctly and the current version. Hence, the history of software plays a vital role in its maintenance. 


The history is important even during the development phase. A VCS makes it easier for the developers to try different implementations and choose one among them. This is either done by having a different implementation in a separate branch or by reverting to a previous version in the same branch in the case the latest implementation did not work. Querying even a shorter history helps the programmer to look at the changes she made and compare them.

Git, which is a distributed version control system has gained immense popularity over the last decade. A 2015 survey by Stackoverflow shows that 69.3$\%$ of the developers prefer git over other version control systems. Github \cite{github} which is a web-based version control system that uses git, hosts over 55 million projects. Hence, we looked at the history of projects that are version controlled by git.

%\textbf{Current commands and tools and why they are not sufficient}

Searching for a word or a sentence in a single file is an easy task supported by many tools.% and commands available. 
One can look for exact words or a pattern of words in which case a regular expression is used to specify the pattern. 
Grep is one such tool in Unix that can search a file using regular expression. 


In a file that is version controlled, searching involves looking into a specific version or all the versions of the file. To find a version that consists of a pattern, the user can create a script that runs grep on all the versions and returns	 the ones that contain the pattern. This brute-force approach is straightforward and easy to implement. However, it is not efficient when there are a huge number of versions.

An alternative is to use the commands provided by the VCS itself. Since these commands directly work on the internal representation, they are faster than the brute-force approach. In the case of git, commands like {\ttf git log}, {\ttf git diff}, and {\ttf git show} along with various options can be used to query the history. Some of the options allow users to search using regular expressions.

However, in cases where the users want to query the changes made to a particular part of the program, git commands do not suffice.
 
%\begin{comment}
%Consider a case where the user is looking for a specific change, that is, some string \textit{s} changed to \textit{t}.
%Git consists of commands that can be used to query what was added or removed in each version. 
%Such a command would return all the versions that added \textit{s} and all the versions that removed \textit{t} instead of just the version that replaced \textit{s} with \textit{t}.  Git also has commands that can track the changes made to a range of lines in the file. However, these are not accurate sometimes since the line numbers keep changing due to addition and deletion of lines.
%Most of these commands are complex and sometimes require external scripts as well.

%Consider a scenario where all the changes made to a function needs to be looked into for debugging purposes. A search for the function name will return all the versions that contain the function.  What we need in this case are all the versions that have some changes made to the function. Git log with the option -L searches the history of a range of lines specified by a start and an end. But this range will change when lines are added or deleted around the function, and therefore not all the changes are captured.
%\end{Comment}

Consider a scenario where two developers, Jen and Bob are working on a program that is version controlled by git, shown in listing~\ref{lst:ex1.1}. The program involves accessing user information from the database. The \ttf{elementOf} function parses a list of users and returns true if an arbitrary user exists otherwise false. This function is used before making expensive database access to retrieve any data about a user. 

\begin{lstlisting}[caption= Code snippet, label=lst:ex1.1, gobble=0, basicstyle=\ttfamily\small]
...
Boolean elementOf(ID userID)
{ 
 String userID = regexLookUp("*userID",this.userList);
  if(userID == "")
   return False;
  else
   return True;
}
...
User getUserInfo(ID userID)
{
 User user = Null;
 if(!elementOf(userID))
  throw new Exception("User not present");
 else
  user = getUserInfoFromDB(userID);
 return user;
}
...
\end{lstlisting}

Jen is working on a new feature and adds few methods to this program. Some of the new methods use \ttf{elementOf}. Listing ~\ref{lst:ex1.2} shows one of the new methods added by Jen.
Bob on the other hand is refactoring the existing code. He changes the method name \ttf{elementOf} to \ttf{isCurrentUser}. However, Bob renames it twice before arriving at this name. First, to \ttf{contains} and then to \ttf{present}, all of them committed to the repository. Listings ~\ref{lst:scr1}, ~\ref{lst:scr2} and ~\ref{lst:scr3} show the differences in each commit that renames the \ttf{elementOf} method.

\begin{lstlisting}[caption= Code snippet, label=lst:ex1.2, gobble=0, basicstyle=\ttfamily\small]
...
Link getUserlinks(ID userID1, ID userID2)
{
 User user1 = Null;
 User user2 = Null;
 if(!elementOf(userID1))
  throw new Exception("User %1 not present", userID1);
 if(!elementOf(userID2))
  throw new Exception("User %1 not present", userID2);
  
 user1 = getUserInfoFromDB(userID1);
 user2 = getUserInfoFromDB(userID2);
 return getlinks(user1,user2);
}
...
\end{lstlisting}

%\begin{figure}
%    \includegraphics[width=150mm]{scr1}
%    \caption{Renamed to \ttf{contains}}\label{fig:scr1}
%\end{figure}

\begin{lstlisting}[caption= Renamed to \ttf{contains}, label=lst:scr1, gobble=0, basicstyle=\ttfamily\small]
$\color{red}\texttt{-Boolean elementOf(ID userID)}$
$\color{green}\texttt{+Boolean contains(ID userID)}$
{
	String userID = regexLookUp("*userID",this.userList)
	if(userID == "")
$\color{blue}\texttt{@@ -19,7 +19,7 @@}$ Boolean elementOf(ID userID)
User getUserInfo(ID userID)
{
	User user = Null;
$\color{red}\texttt{-	if(!elementOf(userID))}$
$\color{green}\texttt{+	if(!contains(userID))}$
		throw new Exception("User not present");
\end{lstlisting}

\begin{lstlisting}[caption= Renamed to \ttf{present}, label=lst:scr2, gobble=0, basicstyle=\ttfamily\small]
$\color{red}\texttt{-Boolean contains(ID userID)}$
$\color{green}\texttt{+Boolean present(ID userID)}$
{
	String userID = regexLookUp("*userID",this.userList)
	if(userID == "")
$\color{blue}\texttt{@@ -19,7 +19,7 @@}$ Boolean elementOf(ID userID)
User getUserInfo(ID userID)
{
	User user = Null;
$\color{red}\texttt{-	if(!contains(userID))}$
$\color{green}\texttt{+	if(!present(userID))}$
		throw new Exception("User not present");
\end{lstlisting}

\begin{lstlisting}[caption= Renamed to \ttf{isCurrentUser}, label=lst:scr3, gobble=0, basicstyle=\ttfamily\small]
$\color{red}\texttt{-Boolean present(ID userID)}$
$\color{green}\texttt{+Boolean isCurrentUser(ID userID)}$
{
	String userID = regexLookUp("*userID",this.userList)
	if(userID == "")
$\color{blue}\texttt{@@ -19,7 +19,7 @@}$ Boolean elementOf(ID userID)
User getUserInfo(ID userID)
{
	User user = Null;
$\color{red}\texttt{-	if(!present(userID))}$
$\color{green}\texttt{+	if(!isCurrentUser(userID))}$
		throw new Exception("User not present");
\end{lstlisting}

%\begin{figure}
%    \includegraphics[width=150mm]{scr2}
%    \caption{Renamed to \ttf{present}}\label{fig:scr2}
%\end{figure}
%\begin{figure}
%    \includegraphics[width=150mm]{scr3}%[width=\columnwidth]{scr3}
%    \caption{Renamed to \ttf{isCurrentUser}}\label{fig:scr3}
%\end{figure}

Both Jen and Bob are working on different branches. First, Bob merges his changes with the main branch. After Jen merges her changes, she finds out that the program does not compile successfully. The method \ttf{elementOf} no longer exists. There are three ways to identify the problem.
\begin{description}
\item[1] Look for the file that contained \ttf{elementOf} and then search through the file that has the same implementation as \ttf{elementOf}.
\item[2] Go through all the commits, made after Jen created the branch, one by one.
\item[3] Search for the commit that renamed the method using the command \ttf{git log -G`elementOf'}. 
\end{description}

Option 1 and 2 are quite tedious if the implementation is complex or if the number of commits are large, respectively. The command in option 3 returns the commits that has \ttf{elementOf} in the added or removed lines. It shows even the commit that added the function for the first time. By going through the commits returned by the command, Jen sees that it was renamed to \ttf{contains}. However, that is not the latest name of the method. Jen has to then search again using \ttf{git log -G`contains'} to know what \ttf{contains} was renamed to and so on until the latest name is known. This comparatively takes less time than the other two options but nonetheless, is tedious.

Hence there is a need for a language that is simple, and that enables users not just to look for patterns but also to look for changes in the history of software repositories.

%\textbf{Prominent feature of GQL: Choice Patterns. Illustrated with an example}

In GQL, users can query the history similar to grep by using regular expressions.
The important feature, however, is to query specific changes. This can be achieved using the ``Choice Patterns."  In a choice pattern, users can specify a pattern for the text in the previous version and another pattern for the text in the later version. Therefore, retrieving only the versions that made such changes. The user can also specify the text in one version and obtain the subsequent changes made to it.

In the above example scenario, in GQL, Jen would query using the choice pattern \chc[d]{\ttf{elementOf},\ttf{\$x}} and obtain all the subsequent changes made to \ttf{elementOf}. The changes will be bound to the variable \ttf{x}. Choice patterns are explained in detail in section \ref{sec:gitql}.

\mytodo{specify the structure of rest of the paper}


\begin{comment}
For example, consider a C program shown in the listing~\ref{lst:v1}. The program consists of two functions along with the other functions; \texttt{get_record} returns a record value from a string in a particular format specified by the global variable \texttt{format}, \texttt{show_record} returns a string in the same format from a record value.

 the pattern to find the version in which a function \textit{foo} was renamed to \textit{bar} is \textit{\chc {foo,bar}}. The syntax for choice pattern is {\chc {\textit{Pattern-before}, \textit{Pattern-after}}}. The character {\dimMeta} is called the dimension which is explained in further sections.

\begin{lstlisting}[caption= C program that formats a record, label=lst:v1, gobble=0, basicstyle=\ttfamily\small]
#include <formatrecord.h>

char format[10] = "NAME:VALUE";

Record get_record(char[] string)
{ return formatter(string,format);}

...
...

char* show_record(Struct Record r)
{ return formatter(r,format);}
\end{lstlisting}
Say, the global variable \texttt{format} was changed twice in subsequent commits by a diferent programmer. In the first commit, the programmer renames the variable from \texttt{format} to \texttt{default_format}. Consequently, renames all the occurrences of \texttt{format}.  In second commit, the programmer adds a new format by creating another variable \texttt{current_format} and propagates the change to the function \texttt{get_record} to accept strings in the newer format. The programmer, however, forgets to rename the variable in the function \texttt{show_record}. Both the versions are shown in the listings ~\ref{lst:v2} and ~\ref{lst:v3} respectively. 

\begin{lstlisting}[caption= Program after the first commit, label=lst:v2, gobble=0, basicstyle=\ttfamily\small]
#include <formatrecord.h>

char default_format[10] = "NAME:VALUE";

Record get_record(char[] string)
{ return formatter(string,default_format);}

...
...

char* show_record(Struct Record r)
{ return formatter(r,default_format);}
\end{lstlisting}

\begin{lstlisting}[caption= Program after the second commit , label=lst:v3, gobble=0, basicstyle=\ttfamily\small]
#include <formatrecord.h>

char default_format[10] = "NAME:VALUE";
char current_format[10] = "NAME:VALUE1,VALUE2";

Record get_record(char[] string)
{ return formatter(string,current_format);}

...
...

char* show_record(Struct Record r)
{ return formatter(r,default_format);}

\end{lstlisting}

Now, the function \texttt{get_record} uses \texttt{current_format} whereas the function \texttt{show_record} uses \texttt{default_format}. 


%The merged program in shown in the listing ~\ref{lst:v4}.

%\begin{lstlisting}[caption= The same C program modified in branch 2 , label=lst:v4, gobble=0, basicstyle=\ttfamily\small]
%#include <formatrecord.h>
%
%char default_format[10] = "NAME:VALUE";
%char current_format[10] = "NAME:VALUE1,VALUE2";
%
%Record get_record(char[] string)
%{ return formatter(string,current_format);}
%
%...
%...
%
%char* show_record(Struct Record r)
%{ return formatter(r,default_format);}
%
%\end{lstlisting}

The program now reads the string in the appropriate format but writes in the old format. The programmer who coded the initial version knows only about the variable \texttt{format}. But the current code has two different variable names and so the programmer now, to understand the changes, wants to view all the changes that were made to the variable. With current git commands, the programmer has to first identify the commit that changed the variable name from \texttt{format} and then look for the commit that changed \texttt{default_format}. In GQL, this can be easily queried using the choice pattern \chc[d]{\texttt{format},\texttt{\$x}}. \texttt{\$x} contains all the new names of \texttt{format}. \texttt{\$x} is a query variable and is explained in the later section.

\end{comment}

%In the case where only one of the patterns is known, the other can simply be a variable which then refers to the entire text that was changed to or from. The texts stored in these variables can simply be displayed or queried further.




%A change in a file that leads to a new version can be viewed as a variation of the original file. Each edit made sequentially will create a new variant. At any point in time, any of these variants can be used. In git, this corresponds to cherry picking or reverting to a particular version. 
%A variational file consists of all the variations encoded in constructs called ``choices". The variational file of a file that is version controlled is created by adding choices for every change that leads to a new version. 
%[Explain Dimensions, alternatives, selections, decision]


%The version history is modelled using the choice edit model for text editors.[Cite, Explain chain edits and branch edits]

\begin{comment}
Software development involves a lot of variations. From changes in the specification to changes in the source code, most of these changes are important and need to be tracked. As the software project evolves over the year, the number of such changes increase. Often, one will look into the history of the project to understand why certain changes were made, to know when and who made those changes or to look for specific changes. This involves querying the history of the software repository. \\
    The paper presents a query language, \gql to search for changes in the history of a repository in Git. The aim is to provide a language that is expressive and intuitive which are lacking in the present command structure of Git.\\
    Using regular expression language to represent the patterns, \gql looks for specific variations in a file. The regular expression language is extended to add a construct to represent what we call a "Choice Pattern." Choice patterns are used to represent a specific change in the history. The entire version history of a file is represented as a variational string using the choice calculus and choice edit model.\\
    Git also provides commands that can be used to query using regular expression patterns. Therefore, we compared the performance of our language against the git commands and a simple script that runs grep command on all the versions of the file. Git commands work directly on its internal representation of the commit and therefore performs slightly faster. On the other hand, \gql performs better than the brute force of approach implemented in the script.
%The remainder of this paper has section 2 giving background on the choice calculus that is used to represent the change history of a file, Section 3 motivating our work with two example queries.
\end{comment}

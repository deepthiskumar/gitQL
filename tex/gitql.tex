GQL provides various constructs that can be used by the programmer to query the history. The most important and the one which forms the crux of the language is the \texttt{vgrep} construct. The variational grep or \texttt{vgrep} takes a pattern and a variational file, looks for the pattern in it and returns all the occurrences of the pattern. The syntax of \texttt{vgrep} is.

\begin{lstlisting}
vgrep pattern variational_file
\end{lstlisting}

The patterns in GQL extends the basic regular expression language to include the choice patterns. The syntax of a pattern is

%\begin{lstlisting}
%$\textit{<pattern>} ::= $\textit{<character>}  
%            | $\textit{<anyCharacter>}
%            | $\textit{<pattern> <pattern>}
%            | $\textit{<pattern> | <pattern>}
%            | $\textit{<dimension> \langle <pattern> , <pattern> \rangle}
%            | $\textit{\textdollar <string>}
%            | $\textit{( <pattern> )}
%character    ::= $\textit{<ascii_character_set>}
%anyCharacter ::= .
%dimension    ::= $\textit{Integer | string}
%string       ::= character string | $\epsilon$

%\end{lstlisting}
\setlength{\grammarindent}{5em} % increase separation between LHS/RHS 
\begin{grammar} 

<pattern> ::= <character>  
            \alt <any-character>
            \alt <pattern> <pattern>
            \alt <pattern> "|" <pattern>
            \alt <dimension> $\langle$ <pattern> "," <pattern> $\rangle$
            \alt "\textdollar"<variable-name>
            \alt "(" <pattern> ")"

<any-character> ::= .

<dimension>    ::= <integer> \alt <dimension-variable> %\alt $\epsilon$

\end{grammar}


A character in a pattern can include any ASCII character. However, since certain symbols are used to denote other patterns, these symbols, called metacharacters, need to be escaped using a backslash in order to search them. Otherwise, they will be treated as metacharacters. %For example, the metacharacter dot (.) is used to specify any character. So, if a user is looking for a pattern that consists of a full stop, then $\backslash$. should be specified in the pattern. This way the search algorithm can correctly interpret the intended use of such symbols.

A sequence of patterns can be formed by concatenating one pattern with the other. This way, the user could search for a string ``\texttt{ab}" or a string followed by a choice pattern ``\texttt{int \chc[1]{\texttt{foo},\texttt{bar}}}" and so on.

A choice pattern, as explained previously can be used to specify the changes. The dimension in a choice pattern can be an integer or a choice variable. In the case of an integer, \texttt{vgrep} looks for a choice with the dimension name equal to the integer specified. This corresponds to searching for the change made by a particular commit. For example, the pattern \chc[1]{\texttt{foo},\texttt{bar}} matches \chc[1]{\texttt{foo},\texttt{bar}} in the variational file but not \chc[2]{\texttt{foo},\texttt{bar}} since the dimension name differs. If a dimension variable is used, then \texttt{vgrep} skips matching of the dimension name and only matches the left and the right patterns . If both the patterns match, then the dimension variable is bound to the dimension name of the matched choice. For example, the pattern \chc[d]{\texttt{foo},\texttt{bar}} matches both \chc[1]{\texttt{foo},\texttt{bar}} and \chc[2]{\texttt{foo},\texttt{bar}} where \textit{d} is bound to 1 and 2 respectively. Dimension variables are useful when the dimension name is unknown or when a pattern could occur in multiple versions. Each match returned by \texttt{vgrep} will have the value to which the dimension variable is bound.
%{\mytodo {Should we specify commit id instead of dimension name?}}

The choice pattern and the alternation pattern are similar in that, both can be used to specify two different patterns. But there is a principle difference between them. Consider, for example, the pattern \texttt{foo|bar}. It matches the choice \chc[1]{\texttt{foo},\texttt{bar}} twice; first with \texttt{foo} and the second time with \texttt{bar}. The semantics of the alternation pattern do not consider the position of the matches which means that either of the two patterns could occur first. Therefore the pattern \texttt{foo|bar} also matches \chc[1]{\texttt{bar},\texttt{foo}}. But the semantics of querying the change \chc[1]{\texttt{foo},\texttt{bar}} is different from that of \chc[1]{\texttt{bar},\texttt{foo}}. In the former choice, it means \texttt{foo} is replaced by \texttt{bar} and in the latter, it means \texttt{bar} is replaced by \texttt{foo}. The choice pattern captures this semantics and produces intended results.

Query variables in a pattern can be used to refer to a part of the query result. This is specifically for choice patterns when the user only knows the pattern for either the old value or the new value in the variational file but wants the change history of that value. By specifying query variables in the right or left alternative of the choice pattern, the user gets the new value or the old value respectively. For example, in the pattern \chc[d]{\texttt{foo},\texttt{\$q1}}, the query variable \texttt{\$q1} is bound to all changes made to the text \texttt{foo} in the variational file since the chain edits are encoded in the right alternative of the choice. These values, to which the query variables are bound, can be simply viewed or further queried.

The result of the query is also variational and stores the context information required to identify its location in the variational file. A match returned by \ttf{vgrep} consists of
\begin{itemize}
\item Part of the variational string that matches the pattern.
\item Position of the match within the variational file.
\item Bindings for the dimension variables, if any.
\item Bindings for the query variables, if any.
\end{itemize}

Further, GQL consists of constructs that operate on the match result obtained from \ttf{vgrep}. This allows the users to write nested queries as well as compose different queries. 

Let \ttf{Q1 = vgrep \chc[d]{\ttf{foo},\ttf{\$x}} vs} be a query that looks for all the changes made to the string \ttf{foo} and stored in the query variable \ttf{\$x}. Let \ttf{vs} be the variational file that encodes all the changes made to the program that consists of the string \ttf{foo}. The query result is referred using \ttf{Q1}. 

The following list shows different queries that can be used to process the \ttf{vgrep} results along with an example.
\mytodo{The example are currently in Haskell. These need to be rewritten once the concrete syntax is formed.}
\begin{itemize}
\item \ttf{count matches} : To count the number of matches returned by a query.
 \begin{description}
 \item Example: \ttf{count Q1} 
 \end{description}
\item \texttt{getDims dim_variable matches} : To view the dimensions that are bound to a particular dimension variable. This is used in the case of choice patterns that uses dimension variables. It essentially lists all the versions in which a match was found.
 \begin{description}
  \item Example: \ttf{getDims "d" Q1} 
 \end{description}
\item \texttt{show matches} : Pretty print the matches returned by a query. Following is an example of a query to view the values bound by the query variable \ttf{\$x}
 \begin{description}
  \item Example: \ttf{pretty (qVar "x" Q1)} 
 \end{description}
\item \texttt{oR matches1 macthes2} : Takes two \texttt{vgrep} results \ttf{matches1}, \ttf{matches2} respectively and returns \ttf{matches2} only if \ttf{matches1} is empty.
 \begin{description}
  \item Example: Consider another query \ttf{Q2} that simply looks for all the occurrences of \ttf{foo}. 
  
         \ttf{Q2 = vgrep foo vs}  
  
  The following query will then return \ttf{Q1} if there are any changes made to the string  \ttf{foo} otherwise it will return \ttf{Q2}.
  
         \ttf{Q1 `oR` Q2}
 \end{description}
\item \texttt{anD matches1 matches2} : Takes two \texttt{vgrep} results \ttf{matches1}, \ttf{matches2} and returns them only if both have successful matches.
 \begin{description}
  \item Example: Consider another query \ttf{Q3} that looks for changes made to \ttf{bar}.

        \ttf{Q3 = vgrep \chc[d1]{\ttf{bar},\ttf{\$y}}}
        
        To compare between the changes made to \ttf{foo} and \ttf{bar}, the user can first check if both the queries have any results at all. 
        
        \ttf{Q1 `anD` Q3}
 \end{description}
\item \texttt{filter filtertype matches} : This construct can be used to filter out certain matches based on the type of filter.
 The syntax of a filter type is:
 \begin{grammar} 

<filtertype> ::= "filterdim" <dimension-variable> <dim-filters>  
            \alt "filtermatch" <match-predicate> 

<dim-filters> ::= "top" <integer>
                 \alt "get" <dim-predicate>

<match-predicate> ::= <predicate-name> <matches> <matches>

<dim-predicate> ::= <predicate-name> <integer>
\end{grammar}

Filters can be applied on the two aspects of a match.
 \begin{description}
  \item[1] Filter based on predicates on the dimension names. For example, the filter type to obtain matches that were made in the latest five versions will be \ttf{filterdim "d" (top 5)}. The filter type to view all the matches that have dimensions greater than 1000 will be \ttf{filterdim "d" (get (> 1000))}. Since dimension names are in the increasing order with respect to the chronological order of commits, this filter type essentially filters out versions that are older than 1000
  \item[2] Filter based on predicates on the matched variational strings. For example, consider the query \ttf{Q3 = vgrep \chc[d1]{\ttf{bar},\ttf{\$y}}}. In order to check if the changes made to \ttf{\$y} and \ttf{\$x} from \ttf{Q1} are the same, the filter type will be \ttf{filtermatch equal Q1 Q3}
 \end{description}
\item \texttt{vgrepAgain pattern matches} : Takes a pattern and a list of matches which were obtained from other queries and looks for the pattern in those matches. This construct allows the user to essentially nest GQL queries. For example, to check if \ttf{\$x} contains ttf{baz}, the user could query the match results bound by \ttf{\$x} of Q1:
 \begin{description}
  \item \ttf{vgrepAgain baz (qVar "x" Q1 )}
 \end{description}
\end{itemize}
{\mytodo : Add concrete syntax for the above list of constructs}
{\mytodo : Add semantics}
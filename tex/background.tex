\subsection{The Choice Calculus}

To achieve the features of GQL, we represent the history of a repository using a formal language for variation called the choice calculus [Cite]. The choice calculus is a generic language that can be applied to an arbitrary object language. The choice calculus consists of \textit{choices} to denote variations. The syntax of a choice is {\chc {A,B,..}} where \textit{A},\textit{B} and so on are called the alternatives. The alternatives could be terms in the object language or choices themselves. Each of the alternatives in a choice leads to a different version. Therefore, a choice represents all possible variations of an expression in the object language from which one can be selected. Using the choice calculus representation, we get a simple tree model that allows to focus on the changes that lead to newer versions.
\mytodo{Cite paper, Eric's Ph.D. thesis, GTTSE tutorial}
Consider the example of two different implementations of a function \texttt{twice}.

\begin{lstlisting}
	int twice(int x) { return x+x; }
        
	int twice(int x) { return 2*x; }
\end{lstlisting}
        
We can capture the variation between the two implementations of the function \texttt{twice} in the choice expression.

\begin{lstlisting}
	int twice(int x) { $\chc{\texttt{x+x},\texttt{2*x}}$; }
\end{lstlisting}

Here, both the alternatives of the choice are terms in the object language, in this case, C.
A choice is bound to a dimension \textit{D}. Two choices can have same or different dimension names. To understand this better, in the above example, consider another implementation where the variable is named as \texttt{y}. Therefore, we now have one additional implementation of the function \texttt{twice}.

\begin{lstlisting}
	int twice(int y) { return y+y; }
        
	int twice(int y) { return 2*y; }
\end{lstlisting}        
	%int twice(int z){ return z+z}
        
	%int twice(int z){ return z*z}
        
The choice expression now has two dimensions, representing a variation in the variable name and function body respectively.%, therefore, capturing the fact that these are variations in two different aspects.

\begin{lstlisting}  
	int twice(int $\chc[B]{\texttt{x},\texttt{y}}$) { return $\chc[A]{\chc[B]{\texttt{x},\texttt{y}}\texttt{+}\chc[B]{\texttt{x},\texttt{y}},\texttt{2*}\chc[B]{\texttt{x},\texttt{y}}}$; } 
\end{lstlisting}


Two choices with dimension name \textit{B} are nested in the choice with dimension name \textit{A} thereby representing variations in multiple levels. This way, all the variants of a program in the object language can be represented using the choice calculus in one variational program.

From a variational program consisting of choices, a concrete program variant can be obtained by recursively selecting an alternative from each choice until all the choices are eliminated. The process of selecting an alternative from a choice is called \textit{selection}. A selection is a mapping from a dimension name to an alternative. The set of selections required to obtain a concrete program is called a \textit{decision}.

From the choice expression in the above example, to obtain the variant of \texttt{twice} which has \texttt{y} as the variable and implemented using \texttt{+}, we have to make two selections; one for the choice of variable names and the other for the choice of the function body. A selection is denoted by \textit{D}.l, \textit{D}.r where \textit{D} is the dimension name and l,r being abbreviation for `Left' and `Right' denotes the first and the second alternatives respectively.%1,2,..n are the indexes of the n alternatives that occur in the same order. 
The decision \{\textit{A}.l, \textit{B}.r\} will select the left alternative from the choice with dimension name \textit{A} and the right alternative from the choices with dimension name \textit{B} and produce the following concrete program in the object language.

\begin{lstlisting}
	int twice(int y) { return y+y; }
\end{lstlisting}
        
Here \textit{B}.R selects the second alternative from all the three choices that are named \textit{B}. The dimension names, therefore, synchronize the changes that are made in different places but are all part of the same variation. 

\subsection{The Choice Edit Model}

To represent the version history of a file using the choice calculus representation, we use the choice edit model[Cite] which is an application of the choice calculus representation. The choice edit model is a program edit model that can be used to understand and reason about the edits that a developer makes while editing a program. In the choice edit model, making an edit to a program is viewed as introducing variation into the program. Whenever a program part \textit{P} is changed to \textit{Q}, a choice between \textit{P} and \textit{Q} is introduced. Here, in a choice, the left alternative consists of the old value and the right alternative consists of the new value. %Consequently, selection can be expressed as \textit{D}.L and \textit{D}.R for left and right alternatives respectively. 
The object language, in this case, is simply a string of characters because we are capturing the textual edits and do not care if the program behavior changes or not.

Consider a C program \texttt{P} which consists of a function \texttt{f}. This is the first version of the function. %No changes have been made to it and therefore the variational program \textit{VP} is same as \textit{P}.

\begin{lstlisting} 
P = int f(int a)
    { int b; return a+b; }
\end{lstlisting}    
%VP = int f(int a)
%     {int b; return a+b;}


A programmer makes the following sequence of edits on \texttt{f}. After each edit, choices are created in the variational program.

\textbf{Edit 1:} Change the function argument to \texttt{c}. in the variation program \texttt{VP1}, a choice with dimension name, say \textit{A}, between \texttt{a} and \texttt{c} is introduced in all the places where the edit is made.

\begin{lstlisting}
P1 = int f(int c)
    { int b; return c+b; }
    
VP1 = int f(int $\chc[A]{\texttt{a},\texttt{c}}$)
     { int b; return $\chc[A]{\texttt{a},\texttt{c}}$+b; }
\end{lstlisting}

\textbf{Edit 2:} Assign the value 1 to the variable \texttt{b}. A choice with a different dimension name, say \textit{B}, between an empty string and ``\texttt{=1}" is introduced. This edit is an insert operation and therefore there is no old value. Similarly, for a delete operation there is no new value and therefore, the choice that represents a delete operation will have an empty string in the right alternative.

\begin{lstlisting}
P2 = int f(int c)
    { int b=1; return c+b; }
    
VP2 = int f(int $\chc[A]{\texttt{a},\texttt{c}}$)
     { int b$\chc[B]{,\texttt{=1}}$; return $\chc[A]{\texttt{a},\texttt{c}}$+b; }
\end{lstlisting}

\textbf{Edit 3:} Change the function argument again to \texttt{d}. A new choice with dimension name, say \textit{C}, is introduced. This edit is changing the string that has already been changed previously and therefore is nested in the right alternative of the choice with dimension name \textit{A}\\
. Such edits are called chain edits.

\begin{lstlisting}
P3 = int f(int d)
    { int b=1; return d+b; }
    
VP3 = int f(int $\chc[A]{\texttt{a},\chc[C]{\texttt{c},\texttt{d}}}$)
     { int b$\chc[B]{,\texttt{=1}}$; return $\chc[A]{\texttt{a},\chc[C]{\texttt{c},\texttt{d}}}$+b; }
\end{lstlisting}

For each edit operation, a new choice is introduced. To synchronize the edits made in different places, the choices are given the same dimension name. The variational program \texttt{VP3} now consists of the information on how the program was edited. It consists of all the edit operations that were made to the initial program \texttt{P}. The latest version can be obtained by selecting the right alternative from all the choices in \texttt{VP3}. The programmer can select any variant by making appropriate selections. For example, the decision \{\textit{A}.r,\textit{B}.l,\textit{C}.r\} will generate a variant that consists of Edit 1 and Edit 3 but not Edit 2 which, in terms of text editing, is called a selective undo. A selective undo feature allows the user to selectively choose which edits made to the program need to undone, instead of linearly undoing all the changes that were made one after the other. Similarly, a selective redo operation allows user to choose the edits that she wants to make again without having to linearly do all the edits. The program variant obtained after applying the decision \{\textit{A}.r,\textit{B}.l,\textit{C}.r\} is

\begin{lstlisting}
int f(int d)
{ int b; return d+b; }
\end{lstlisting}